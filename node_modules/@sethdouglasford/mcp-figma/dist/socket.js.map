{"version":3,"sources":["../src/socket.ts"],"sourcesContent":["import WebSocket, { WebSocketServer } from 'ws';\nimport http from 'http';\n\n// Store clients by channel\nconst channels = new Map<string, Set<WebSocket>>();\n\nfunction handleConnection(ws: WebSocket) {\n  // Don't add to clients immediately - wait for channel join\n  console.log(\"New client connected\");\n\n  // Send welcome message to the new client\n  ws.send(JSON.stringify({\n    type: \"system\",\n    message: \"Please join a channel to start chatting\",\n  }));\n\n  ws.on('close', () => {\n    console.log(\"Client disconnected\");\n\n    // Remove client from their channel\n    channels.forEach((clients, channelName) => {\n      if (clients.has(ws)) {\n        clients.delete(ws);\n\n        // Notify other clients in same channel\n        clients.forEach((client) => {\n          if (client.readyState === WebSocket.OPEN) {\n            client.send(JSON.stringify({\n              type: \"system\",\n              message: \"A user has left the channel\",\n              channel: channelName\n            }));\n          }\n        });\n      }\n    });\n  });\n\n  ws.on('message', (message: Buffer) => {\n    try {\n      console.log(\"Received message from client:\", message.toString());\n      const data = JSON.parse(message.toString());\n\n      if (data.type === \"join\") {\n        const channelName = data.channel;\n        if (!channelName || typeof channelName !== \"string\") {\n          ws.send(JSON.stringify({\n            type: \"error\",\n            message: \"Channel name is required\"\n          }));\n          return;\n        }\n\n        // Create channel if it doesn't exist\n        if (!channels.has(channelName)) {\n          channels.set(channelName, new Set());\n        }\n\n        // Add client to channel\n        const channelClients = channels.get(channelName)!;\n        channelClients.add(ws);\n\n        // Notify client they joined successfully\n        ws.send(JSON.stringify({\n          type: \"system\",\n          message: `Joined channel: ${channelName}`,\n          channel: channelName\n        }));\n\n        console.log(\"Sending message to client:\", data.id);\n\n        ws.send(JSON.stringify({\n          type: \"system\",\n          message: {\n            id: data.id,\n            result: \"Connected to channel: \" + channelName,\n          },\n          channel: channelName\n        }));\n\n        // Notify other clients in channel\n        channelClients.forEach((client) => {\n          if (client !== ws && client.readyState === WebSocket.OPEN) {\n            client.send(JSON.stringify({\n              type: \"system\",\n              message: \"A new user has joined the channel\",\n              channel: channelName\n            }));\n          }\n        });\n        return;\n      }\n\n      // Handle regular messages\n      if (data.type === \"message\") {\n        const channelName = data.channel;\n        if (!channelName || typeof channelName !== \"string\") {\n          ws.send(JSON.stringify({\n            type: \"error\",\n            message: \"Channel name is required\"\n          }));\n          return;\n        }\n\n        const channelClients = channels.get(channelName);\n        if (!channelClients || !channelClients.has(ws)) {\n          ws.send(JSON.stringify({\n            type: \"error\",\n            message: \"You must join the channel first\"\n          }));\n          return;\n        }\n\n        // Broadcast to all clients in the channel\n        channelClients.forEach((client) => {\n          if (client.readyState === WebSocket.OPEN) {\n            console.log(\"Broadcasting message to client:\", data.message);\n            client.send(JSON.stringify({\n              type: \"broadcast\",\n              message: data.message,\n              sender: client === ws ? \"You\" : \"User\",\n              channel: channelName\n            }));\n          }\n        });\n      }\n    } catch (err) {\n      console.error(\"Error handling message:\", err);\n    }\n  });\n}\n\n// Create HTTP server\nconst server = http.createServer((req, res) => {\n  // Handle CORS\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  \n  if (req.method === 'OPTIONS') {\n    res.writeHead(200);\n    res.end();\n    return;\n  }\n  \n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('WebSocket server running');\n});\n\n// Create WebSocket server\nconst wss = new WebSocketServer({ server });\n\nwss.on('connection', handleConnection);\n\nconst port = 3055;\nserver.listen(port, () => {\n  console.log(`WebSocket server running on port ${port}`);\n});\n"],"mappings":"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","names":[]}